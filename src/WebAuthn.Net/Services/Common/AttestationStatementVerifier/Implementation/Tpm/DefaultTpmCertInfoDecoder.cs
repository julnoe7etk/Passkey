using System;
using System.Buffers.Binary;
using System.Diagnostics.CodeAnalysis;
using WebAuthn.Net.Models;
using WebAuthn.Net.Services.Common.AttestationStatementVerifier.Abstractions.Tpm;
using WebAuthn.Net.Services.Common.AttestationStatementVerifier.Abstractions.Tpm.Models.Attestation;
using WebAuthn.Net.Services.Common.AttestationStatementVerifier.Abstractions.Tpm.Models.Attestation.Enums;

namespace WebAuthn.Net.Services.Common.AttestationStatementVerifier.Implementation.Tpm;

/// <summary>
///     Default implementation of <see cref="ITpmCertInfoDecoder" />.
/// </summary>
public class DefaultTpmCertInfoDecoder : ITpmCertInfoDecoder
{
    /// <inheritdoc />
    public virtual Result<CertInfo> Decode(Span<byte> bytes)
    {
        var buffer = bytes;
        // 10.12.12 TPMS_ATTEST
        // This structure is used on each TPM-generated signed structure.
        // The signature is over this structure.
        // When the structure is signed by a key in the Storage hierarchy, the values of clockInfo.resetCount, clockInfo.restartCount, and firmwareVersion are obfuscated with a per-key obfuscation value.
        // Table 132 — Definition of TPMS_ATTEST Structure <OUT>
        // | Parameter       | Type            | Description
        // | magic           | TPM_GENERATED   | The indication that this structure was created by a TPM (always TPM_GENERATED_VALUE)
        // | type            | TPMI_ST_ATTEST  | Type of the attestation structure
        // | qualifiedSigner | TPM2B_NAME      | Qualified Name of the signing key
        // | extraData       | TPM2B_DATA      | External information supplied by caller.
        // |                 |                 |   NOTE: A TPM2B_DATA structure provides room for a digest and a method indicator to indicate the components of the digest.
        // |                 |                 |         The definition of this method indicator is outside the scope of this specification.
        // | clockInfo       | TPMS_CLOCK_INFO | Clock, resetCount, restartCount, and Safe
        // | firmwareVersion | UINT64          | TPM-vendor-specific value identifying the version number of the firmware
        // | [type]attested  | TPMU_ATTEST     | The type-specific attestation information

        // magic
        // 6.2 TPM_GENERATED
        // This constant value differentiates TPM-generated structures from non-TPM structures.
        // Table 7 — Definition of (UINT32) TPM_GENERATED Constants <O>
        // | Name                | Value      | Comments
        // | TPM_GENERATED_VALUE | 0xff544347 | 0xFF 'TCG' (FF 54 43 47)
        if (!TryConsume(ref buffer, 4, out var rawMagic))
        {
            return Result<CertInfo>.Fail();
        }

        var magic = BinaryPrimitives.ReadUInt32BigEndian(rawMagic);
        // https://www.w3.org/TR/2023/WD-webauthn-3-20230927/#sctn-tpm-attestation
        // §8.3. TPM Attestation Statement Format
        // Validate that certInfo is valid:
        // 1) Verify that magic is set to TPM_GENERATED_VALUE.
        if (magic != 0xff544347)
        {
            return Result<CertInfo>.Fail();
        }

        // type
        // According to the WebAuthn specification, only TPM_ST_ATTEST_CERTIFY is allowed
        // 10.12.10 TPMI_ST_ATTEST
        // Table 130 — Definition of (TPM_ST) TPMI_ST_ATTEST Type <OUT>
        // | Value                       | Description
        // | TPM_ST_ATTEST_CERTIFY       | generated by TPM2_Certify()
        // | TPM_ST_ATTEST_QUOTE         | generated by TPM2_Quote()
        // | TPM_ST_ATTEST_SESSION_AUDIT | generated by TPM2_GetSessionAuditDigest()
        // | TPM_ST_ATTEST_COMMAND_AUDIT | generated by TPM2_GetCommandAuditDigest()
        // | TPM_ST_ATTEST_TIME          | generated by TPM2_GetTime()
        // | TPM_ST_ATTEST_CREATION      | generated by TPM2_CertifyCreation()
        // | TPM_ST_ATTEST_NV            | generated by TPM2_NV_Certify()
        // | TPM_ST_ATTEST_NV_DIGEST     | generated by TPM2_NV_Certify()
        // 6.9 TPM_ST (Structure Tags)
        // Table 19 — Definition of (UINT16) TPM_ST Constants <IN/OUT, S>
        // | Name                  | Value  | Comments
        // | TPM_ST_ATTEST_CERTIFY | 0x8017 | Tag for an attestation structure
        if (!TryConsume(ref buffer, 2, out var rawType))
        {
            return Result<CertInfo>.Fail();
        }

        var type = BinaryPrimitives.ReadUInt16BigEndian(rawType);
        // https://www.w3.org/TR/2023/WD-webauthn-3-20230927/#sctn-tpm-attestation
        // §8.3. TPM Attestation Statement Format
        // Validate that certInfo is valid:
        // 2) Verify that type is set to TPM_ST_ATTEST_CERTIFY.
        if (type != 0x8017)
        {
            return Result<CertInfo>.Fail();
        }

        // qualifiedSigner
        // 10.5.3 TPM2B_NAME
        // This buffer holds a Name for any entity type.
        // The type of Name in the structure is determined by context and the size parameter.
        // If size is four, then the Name is a handle.
        // If size is zero, then no Name is present.
        // Otherwise, the size shall be the size of a TPM_ALG_ID plus the size of the digest produced by the indicated hash algorithm.
        // Table 91 — Definition of TPM2B_NAME Structure
        // | Name                           | Type   | Description
        // | size                           | UINT16 | size of the Name structure
        // | name[size]{:sizeof(TPMU_NAME)} | BYTE   | The Name structure
        var qualifiedSignerResult = DecodeTpm2BName(ref buffer);
        if (qualifiedSignerResult.HasError)
        {
            return Result<CertInfo>.Fail();
        }

        // extraData
        // 10.4.3 TPM2B_DATA
        // This structure is used for a data buffer that is required to be no larger than the size of the Name of an object.
        // Table 81 — Definition of TPM2B_DATA Structure
        // | Name                           | Type   | Description
        // | size                           | UINT16 | size in octets of the buffer field; may be 0
        // | buffer[size]{:sizeof(TPMT_HA)} | BYTE   |
        if (!TryConsume(ref buffer, 2, out var rawExtraDataSize))
        {
            return Result<CertInfo>.Fail();
        }

        // extraData.size
        var extraDataSize = BinaryPrimitives.ReadUInt16BigEndian(rawExtraDataSize);
        var extraData = new byte[extraDataSize];
        // extraData.buffer
        if (extraDataSize > 0)
        {
            if (!TryConsume(ref buffer, extraDataSize, out var rawExtraData))
            {
                return Result<CertInfo>.Fail();
            }

            if (!rawExtraData.TryCopyTo(extraData.AsSpan()))
            {
                return Result<CertInfo>.Fail();
            }
        }

        // clockInfo
        // 10.11.1 TPMS_CLOCK_INFO
        // This structure is used in each of the attestation commands.
        // Table 120 — Definition of TPMS_CLOCK_INFO Structure
        // | Name         | Type        | Description
        // | clock        | UINT64      | Time value in milliseconds that advances while the TPM is powered
        // |              |             |   NOTE: The interpretation of the time-origin (clock=0) is out of the scope of this specification,
        // |              |             |         although Coordinated Universal Time (UTC) is expected to be a common convention.
        // |              |             |         This structure element is used to report on the TPM's Clock value.
        // |              |             | This value is reset to zero when the Storage Primary Seed is changed (TPM2_Clear()).
        // |              |             | This value may be advanced by TPM2_ClockSet().
        // | resetCount   | UINT32      | Number of occurrences of TPM Reset since the last TPM2_Clear()
        // | restartCount | UINT32      | Number of times that TPM2_Shutdown() or _TPM_Hash_Start have occurred since the last TPM Reset or TPM2_Clear().
        // | safe         | TPMI_YES_NO | No value of Clock greater than the current value of Clock has been previously reported by the TPM. Set to YES on TPM2_Clear().

        // clockInfo.clock
        if (!TryConsume(ref buffer, 8, out var rawClockInfoClock))
        {
            return Result<CertInfo>.Fail();
        }

        var clockInfoClock = BinaryPrimitives.ReadUInt64BigEndian(rawClockInfoClock);

        // clockInfo.resetCount
        if (!TryConsume(ref buffer, 4, out var rawClockInfoResetCount))
        {
            return Result<CertInfo>.Fail();
        }

        var clockInfoResetCount = BinaryPrimitives.ReadUInt32BigEndian(rawClockInfoResetCount);

        // clockInfo.restartCount
        if (!TryConsume(ref buffer, 4, out var rawClockInfoRestartCount))
        {
            return Result<CertInfo>.Fail();
        }

        var clockInfoRestartCount = BinaryPrimitives.ReadUInt32BigEndian(rawClockInfoRestartCount);

        // clockInfo.safe
        // 9.2 TPMI_YES_NO
        // This interface type is used in place of a Boolean type in order to eliminate ambiguity in the handling of a octet that conveys a single bit of information.
        // This type only has two allowed values, YES (1) and NO (0).
        // Table 40 — Definition of (BYTE) TPMI_YES_NO Type
        // | Value | Description
        // | NO    | a value of 0
        // | YES   | a value of 1
        if (!TryConsume(ref buffer, 1, out var rawClockInfoSafe))
        {
            return Result<CertInfo>.Fail();
        }

        bool clockInfoSafe;
        switch (rawClockInfoSafe[0])
        {
            case 0:
                clockInfoSafe = false;
                break;
            case 1:
                clockInfoSafe = true;
                break;
            default:
                return Result<CertInfo>.Fail();
        }

        // firmwareVersion UINT64
        if (!TryConsume(ref buffer, 8, out var rawFirmwareVersion))
        {
            return Result<CertInfo>.Fail();
        }

        var firmwareVersion = BinaryPrimitives.ReadUInt64BigEndian(rawFirmwareVersion);

        // [type]attested
        // According to the WebAuthn specification, only TPM_ST_ATTEST_CERTIFY is allowed
        // 10.12.11 TPMU_ATTEST
        // Table 131 — Definition of TPMU_ATTEST Union <OUT>
        // | Parameter | Type              | Selector
        // | certify   | TPMS_CERTIFY_INFO | TPM_ST_ATTEST_CERTIFY
        // 10.12.3 TPMS_CERTIFY_INFO
        // This is the attested data for TPM2_Certify().
        // Table 123 — Definition of TPMS_CERTIFY_INFO Structure <OUT>
        // | Parameter     | Type       | Description
        // | name          | TPM2B_NAME | Name of the certified object
        // | qualifiedName | TPM2B_NAME | Qualified Name of the certified object
        var attestedNameResult = DecodeTpm2BName(ref buffer);
        if (attestedNameResult.HasError)
        {
            return Result<CertInfo>.Fail();
        }

        var attestedQualifiedNameResult = DecodeTpm2BName(ref buffer);
        if (attestedQualifiedNameResult.HasError)
        {
            return Result<CertInfo>.Fail();
        }

        if (buffer.Length > 0)
        {
            return Result<CertInfo>.Fail();
        }

        var certInfo = new CertInfo(
            qualifiedSignerResult.Ok,
            extraData,
            clockInfoClock,
            clockInfoResetCount,
            clockInfoRestartCount,
            clockInfoSafe,
            firmwareVersion,
            new(new(attestedNameResult.Ok, attestedQualifiedNameResult.Ok)));
        return Result<CertInfo>.Success(certInfo);
    }

    /// <summary>
    ///     Decodes TPM2B_NAME from binary representation to a typed format for further processing.
    /// </summary>
    /// <param name="buffer">Buffer containing the binary representation of TPM2B_NAME.</param>
    /// <returns>If the decoding was successful, the result contains the <see cref="Tpm2BName" />; otherwise, the result indicates that an error occurred during the decoding process.</returns>
    public virtual Result<Tpm2BName> DecodeTpm2BName(ref Span<byte> buffer)
    {
        // 10.5.3 TPM2B_NAME
        // This buffer holds a Name for any entity type.
        // The type of Name in the structure is determined by context and the size parameter.
        // If size is four, then the Name is a handle.
        // If size is zero, then no Name is present.
        // Otherwise, the size shall be the size of a TPM_ALG_ID plus the size of the digest produced by the indicated hash algorithm.
        // Table 91 — Definition of TPM2B_NAME Structure
        // | Name                           | Type   | Description
        // | size                           | UINT16 | size of the Name structure
        // | name[size]{:sizeof(TPMU_NAME)} | BYTE   | The Name structure
        // 10.5.2 TPMU_NAME
        // Table 90 — Definition of TPMU_NAME Union <>
        // | Parameter | Type       | Selector | Description
        // | digest    | TPMT_HA    |          | when the Name is a digest
        // | handle    | TPM_HANDLE |          | when the Name is a handle
        // 10.3.2 TPMT_HA
        // Table 79 shows the basic hash-agile structure used in this specification.
        // To handle hash agility, this structure uses the hashAlg parameter to indicate the algorithm used to compute the digest and,
        // by implication, the size of the digest.
        // Table 79 — Definition of TPMT_HA Structure <IN/OUT>
        // | Parameter        | Type           | Description
        // | hashAlg          | +TPMI_ALG_HASH | selector of the hash contained in the digest that implies the size of the digest
        // | [hashAlg] digest | TPMU_HA        | the digest data
        if (!TryConsume(ref buffer, 2, out var rawSize))
        {
            return Result<Tpm2BName>.Fail();
        }

        var size = BinaryPrimitives.ReadUInt16BigEndian(rawSize);
        if (size == 0)
        {
            var emptyResult = new Tpm2BName(null, null);
            return Result<Tpm2BName>.Success(emptyResult);
        }

        if (size == 4)
        {
            if (!TryConsume(ref buffer, 4, out var rawHandle))
            {
                return Result<Tpm2BName>.Fail();
            }

            var handle = BinaryPrimitives.ReadUInt32BigEndian(rawHandle);
            var resultHandle = new TpmHandle(handle);
            var handleResult = new Tpm2BName(null, resultHandle);
            return Result<Tpm2BName>.Success(handleResult);
        }

        if (size < 4)
        {
            return Result<Tpm2BName>.Fail();
        }

        if (!TryConsume(ref buffer, size, out var rawName))
        {
            return Result<Tpm2BName>.Fail();
        }

        var hashAlg = (TpmAlgIdHash) BinaryPrimitives.ReadUInt16BigEndian(rawName[..2]);
        if (!Enum.IsDefined(hashAlg))
        {
            return Result<Tpm2BName>.Fail();
        }

        var digest = new byte[size - 2];
        var rawDigest = rawName[2..];
        if (!rawDigest.TryCopyTo(digest.AsSpan()))
        {
            return Result<Tpm2BName>.Fail();
        }

        var resultDigest = new TpmtHa(hashAlg, digest);
        var digestResult = new Tpm2BName(resultDigest, null);
        return Result<Tpm2BName>.Success(digestResult);
    }

    /// <summary>
    ///     Attempts to consume the specified number of bytes from the input Span and return them as a separate out parameter.
    /// </summary>
    /// <param name="input">Input Span from which it is necessary to consume the specified number of bytes.</param>
    /// <param name="bytesToConsume">The number of bytes that need to be consumed.</param>
    /// <param name="consumed">Output Span containing the consumed bytes if the operation was successful. </param>
    /// <returns>
    ///     If it returns <see langword="true" />, it means that the specified amount of bytes has been consumed from the input Span and the consumed bytes have been returned as a separate out parameter, simultaneously decreasing the input Span by the number of consumed bytes.
    ///     Otherwise, it returns <see langword="false" />, leaves the default value in the out parameter, and does not affect the input Span.
    /// </returns>
    [SuppressMessage("ReSharper", "MemberCanBePrivate.Global")]
    protected static bool TryConsume(ref Span<byte> input, int bytesToConsume, out Span<byte> consumed)
    {
        if (input.Length < bytesToConsume)
        {
            consumed = default;
            return false;
        }

        consumed = input[..bytesToConsume];
        input = input[bytesToConsume..];
        return true;
    }
}
